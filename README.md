# 개발자 면접 준비

여러 회사의 기술 먼접을 보면서 공통으로 나왔던 질문을 정리합니다


## 공통 질문

- 자기소개
- 지원이유?
- 퇴사이유는?
- 성격의 장단점은?
- 좋은 개발자란?
- 일하기 좋은 동료는?
- 어려웠던 프로젝트는 무엇이고 해결 방법은?
- 한정된 리소스에서 품질을 유지하기 위한 방법은 무엇?
- 최근 읽은 책 및 아티클은?
- 5년, 10년 후의 모습은? 또는 목표는?
- AI를 실무에서 어떻게 사용중인가?

## 기술 질문

### CS

<details> 
<summary>프로세스 스레드 차이</summary>

프로세스는 보통의 프로그램이라 생각하면 됨 각각 메모리를 독립적으로 사용함
스레드는 프로세스 안에서 실행되는 단위이며 프로세스의 메모리를 공유한다
스레드는 병렬처리에 사용되며 이때 스레드 락을 사용해서 같은 메모리에 접근시 주의가 필요하다
뮤텍스, 세마포어 락이 있고
뮤텍스는 한번에 하나만 접근하게 하는 락
세마포어는 카운트락으로 정해진 개수의 스레드만 접근하는 구조이다
그외에 읽기에서는 모두가 접근가능하고 쓰기에대해서만 한번에 하나만 접근하는 락도 있다
락사용시 데드락이 발생할수 잇고 타임아웃을 적절히 설정하여 무기한 대기되는 상태를 만들지 않아야 한다
</details>


### 데이터베이스

<details> 
<summary> 트랜잭션</summary>
원자성 일관성 독립성 지속성
원자성은 모두 실패하거나 모두 성공해야 한다
독립성은 트랜잭션간 간섭이 일어나지 않는다. 영향을 주지않는다
지속성을 커밋된 내용은 계속 지속되어야 한다
일관성은 db 정책이 변경되지 않아야한다. 이름이 필수인 정책이 있을때 이를 위반하는 데이터 추가하려고 하면 데이터 추가는 실패하고 이름 필수값이라는 정책은 계속 유지되어야 한다
</details> 

<details> 
<summary> 인덱스 </summary>
btree b+tree, 정렬, 범위검색에 유리함
해시인덱스: 정확한 값 비교
비트맵인덱스: 카디널리티 적을때, 성별같은 데이터
풀텍스트인덱스: 엘라스틱서치와 같이 자연어 검색이 필요할때 유리
</details> 


<details> 
<summary> select 쿼리 지연시 확인사항 </summary>
explain analysis를 사용하여 실행 계획을 확인한다

- type컬럼에서 all인지 등을 확인하여 풀스캔 되는지 확인한다. ref, const 등이 이상적
- rows 컬럼 확인하여 스캔 행수를 확인하고 높으면 비효율적
- key를 확인하여 선택된 인덱스가 무엇인지 확인합니다
- using filesort 정렬이 메모리/디스크에서 처리되는것
- using temporary 임시테이블 생성되는지 확인

인덱스 최적화

- where, join, order by, group by 에서 사용되는 컬럼에 인덱스가 누락되엇는지 확인합니다
- 복합 인덱스에서 일부만 사용되거나 하는 경우로 복합키 인덱스가 유효하지 않은지 확인

쿼리 재작성

- 와일드 카드 위치 `%test`  와 같이 앞부붙에 와일드 카드가 오면 인덱스 사용이 불가
- select * 대신 필요한 컬럼만 조회한다
- where에 year(date_col) = 2024 등 함수 연산을 사용하면 인덱스를 무력화 하므로 피해야함
- 서브쿼리 대신 join으로 풀어서 작성할수 잇는지 검사
</details> 

<details> 
<summary>복합키 </summary>
두개 이상의 컬럼을 조합해 하나의 키로 만드는것, 이를 통해 데이터 중복을 방지할 수 있음 

- user_id, order_id 등으로 중복 주문 생성 방지 가능

앞쪽 컬럼이 정렬 우순선위 높음, 앞쪽 컬럼부터 범위를 좁힘 btree사용

쿼리 패턴을 보고 정하는게 좋음

a, b, c 로 정의 되었다면 (a), (a, b) 조건으로 검색할때는 인덱스 활용하지만 b, c만 단독 으로 사용하면 인덱스를 거의 사용하지 못함

가장 자주 사용되고 카디널리티가 높은 컬럼을 복합키의 가장 앞 순서에 배치하면 인덱스 활용도 높아짐

- user_id 등이 카디널리티가 높으므로 우선순위를 높이면 행을 더 좁혀서 탐색 범위가 줄어듬
</details> 

<details> 
<summary>select related, prefetch_related </summary>
셀렉트는 1:1, n:1에서 사용
프리패치는 1:n, n:m에서 사용하며 쿼리시 연결관계의 데이터도 한번에 불러와
액티브 레코드 데이터에서 속성 접근할때 추가 쿼리가 발생하지 않도록 함
</details> 

<details> 
<summary> MySQL, Postgres </summary>
mysql은 읽기 중심에 유리하고 수평 스케일에 강점이 있어 대규모 트래픽 대응에 많이 활용됨
레플리케이션 구성 마스터, 슬래이브, 읽기 전용 레플리케이션 구성하는 등
postgres는 복잡한 쿼리를 사용하여 통계, 분석할때 많이 활용되며
플러그인을 추가하여 fulltext를 사용한 검색 엔진을 구성하거나 vectordb로 활용할수있음
</details> 

<details> 
<summary>char, varchar, text</summary>
char 고정길이로 처리하고 빈공간은 패딩 처리, 읽기 빠름, 국가코드 상태값등에서 사용
varchar 가변길이로 사용한 만큼만 저장, 인덱스, 정렬에 사용할수 잇음
text 64kb까지 저장, 엄청 킨 문자열 처리에 유용, 별도 메모리에 저장됨, 저장목적으로 사용
</details> 

<details> 
<summary>timestamp, datetime</summary>
timestamp는 1970-01-01 부터 사용

데이트 타임은 입력된 내용 그대로 저장(문자열처럼), 서버 타임존과 무관하게 변환 없이 저장됨

타임스탬프는 서버타임존으로 utc로 변환해 저장, 조회시 utc를 다시 서버 타임존으로 변환
</details> 

<details> 
<summary>lock</summary>
테이블락 : ddl 작업시 테이블을 전체 잠그기, 

로우락 : 이노디비 핵심기능

- 베타락 : 쓰기 전용, for update를 사용해서 수정, 삭제 작업전에 락 걸기
- 공유락: 읽기 전용으로 공유락은 허용, 일관성있는 읽기 작업을 위해 락 걸기
- 갭략: 레코드 사이 빈 공간까지 잠금, 다른 트랜잭션이 gap에 데이터 추가하여 팬텀리드 되는 문제 막기 위해 사용, where 절에 범위 조건을 추가하여 사용
</details> 



### 파이썬

<details> 
<summary>`is`와 `==` 차이</summary>

is: id가 같은지 비교(메모리)
같은 객체인지 확인, 빠름
==: 값, 콘텐츠 비교

Deep Copy vs Shallow Copy (복잡한 리스트 복사 시 주의점)?
Shallow Copy? 상위 구조만 복사하고 내부 데이터는 참조 공유
deep copy: 모든 레벨 데이터 복사

</details> 

<details>
<summary> GIL </summary>
파이썬에서는 grobal interfreter lock으로 cpu bound 멀티스레딩에 제한이 있다.
최근 3.13 버전 이후에는 gil을 사용할지 선택할수 잇다
파이선에서 비동기 처리를위해 몇가지 방법이있다
cpu bound(복잡한계산)에서 비동기 처리가 필요하다면 멀티프로세싱을 사용한다
io bound (api, db, file)에서 비동기 처리가 필요하다면 멀티스레딩, asyncio를 사용해도 좋다
asyncio는 단일스레드에서 이벤트루프(코루틴)을 사용하여 여러 함수가 빠르게 번갈아가며 동작을 실행하는 방식이라 사용할만하다
asynio는 async, await 키워드를 사용해야 하며 동작 관련 함수들이 모두 해당 키워드가 있어야 한다
반면 멀티스레딩 패키지 사용시에는 async await이 없더라도 사용가능하지만 asyncio에 비해 메모리 사용량이 많다
둘다 io bound영역에서 활용하면 좋다

gc에서 참조 카운팅을 사용해 객체의 참조 수를 추적하고 0이 되면 메모리를 해제함 그런데 멀티스레드에서 동시에 카운트를 가감하면 충돌이 발생할수있고 원치 않게 메모리 해제되거나 해제되지 않는등 오버헤드 발생할수 잇음 그래서 한번에 하나의 스레드만 사용하도록 제한함
</details>

<details> 
<summary> GC</summary>
참조 카운팅 방식을 사용한다. 참조회수를 추적하고 참조 회수가 0이면 메모리 해제 동작 시점은 할당, 해제를 파악하여 스세솔드 정해서 동작함

세대기반 동작으로 순환참조 변수를 정리함

0세대는 가장 최근 1세대, 2세대는 살아 남은 변수들
</details> 

<details> 
<summary> 데코레이터</summary>
함수를 인자로 받아 기능을 확장하고 다시 함수를 반환하는 패턴, 로깅, 인증, 캐시에 주로 사용된다

제네레이터?
이터레이터와 비슷하며 yield를 사용하여 필요할때 데이터를 순회하여 가져오는 방식
이터레이터는 메모리에 데이터를 모드 적재하고 꺼내쓰는 방식
대용량 파일을 읽어올때 제네레이터 쓰면 메모리를 효율적으로 쓸 수 있다

뮤터블, 이뮤터블 차이?
파이썬에서 리스트, 셋, 딕트는 뮤터블이고 함수의 파라미터로 사용할때 주의가 필요하다
이뮤터블은 int, tuple, str
</details> 

### 웹

<details> 
<summary> 브라우져에서 도메인 입력후 흐름</summary>
브라우저 사용흐름?
URL을 파싱한다.
DNS로 도메인의 IP를 찾는다.
서버와 TCP 연결을 맺는다.
HTTPS라면 TLS로 암호화 채널을 만든다.
서버에 HTTP 요청을 보낸다.
서버가 HTML 등 리소스를 응답한다.
브라우저가 HTML과 리소스를 렌더링한다.
</details> 

<details> 
<summary> TLS </summary>
tls는 ssl후속기능, https:// 가 tls를 사용하는 프로토콜
데이터 암호화 통신 내용을 암호화하고
전송중에 데이터가 변경되지 않음을 보방하고
사용자가 접속하는 서버가 신뢰할수 잇는 서버인지 확인한다
</details> 


<details> 
<summary> HTTP2 </summary>
http2는 바이너리형식의 프로토콜이며 멀티플렉싱을 지원함, 데이터를 프레임단위로 쪼개고 이를 한번에 동시다발적으로 순서상관없이 전송한다
http1의 네트워크 지연, 블로킹문제를 해결한다 또한 헤더 압축으로 중복데이터를 줄인다
</details> 

<details> 
<summary> CORS </summary>
corss origin resource sharing
cors는 브라우저영역에서 한 출처의 웹페이지가 다른 출처의 리소스에 접근하는것을 막음
다른곳의 리소스에 접근하는것을 막는것, 악의적인 탈취를 막기위해서
보통 서버에서 Access-Control-Allow-Origin 헤더를 포함하여 응답함
</details> 

<details> 
<summary> 세션, 토큰 차이</summary>
사용자 인증 정보를 처리할때 사용된다
세션은 사용자 인증정보를 백엔드에 db, redis에 저장하고 액세스 토큰을 클라이언트에 전달한다
로그인 이후 서비스 사용시 헤더에 토큰을 전달하여 인증된 사용자인지 매번 체크하게 된다
백엔드에서 관리하므로 백엔드 부담이 크다. 사용자가 1억명이면 1억개 세션을 관리해야 하는 상황이 발생할 수 있다.
반면 특정사용자가 토큰을 탈취당할경우 그 사용자의 세선 데이터만 제거하여 대응할수 잇으므로 관리가 용이하다
</details> 

<details> 
<summary> JWT</summary>
jwt 토큰 방식은 로그인 후 사용자에게 액세스 토큰을 전달하고 인증 정보를 서버에 저장하지 않는다
jwt 토큰은 헤더, 페이로드, 시그니쳐로 구성되며 헤더에는 알고리즘 정보, 페이로드에는 사용자 메타 정보(식별자, 만료일자), 시그니쳐는 헤더와 페이로드를 합쳐 암호화한 정보로 구성되며 클라이언트가 저장한다
서비스 사용시 클라이언트는 헤더에 토큰을 전달하고 서버는 토큰을 파싱하고 시그니쳐 내용이 헤더, 페이로드의 내용과 일치하는지 확인, 페이로드의 만료일자가 유효한지 확인하여 사용자를 인증한다
서버의 부담이 없는점이 장점이다 반면 사용자가 토큰 탈취시 서버에서 대응이 어렵다
대게 리프레시 토큰을 같이 운용한다. 액세스 토큰은 만료일자를 굉장히 짧게 가져가고 리프레시 토큰을 사용하여 주기적으로 재발급 받도록하여 탈취 위험을 줄인다. 리프레시 토큰은 http only 옵션을 사용하도록하여 유출 문제를 막는다
리프레시 토큰은 백엔드에 저장한다. 수명주기는 30일로 설정한다. 활성사용자는 서비스 접속시 ttl을 늘려서 불편함을 최소화하고 비활성사용자는 30일 이후 토큰을 삭제하여 서버 부담을 줄인다
</details> 

<details> 
<summary> HTTP Only</summary>
자바스크립트에서 접근 불가능하도록 하는 옵션, 서버에서만 읽을수 있도록함, 주로 리프레시 토큰이 이 옵션을 사용함
</details> 


<details> 
<summary> XSS</summary>
cross site scripting
공격자가 웹 사이트에 악성 스크립트를 사입하여 공격하는 방법
쿠키, 세션 정보 탈취, 웹사이트 변조
</details> 

<details> 
<summary> CSRF</summary>
cross site request forgery
로그인된 사용자가 자신도 모르게 공격자가 의도한 행동을 대신 수행하도록 하는 공격기법
백엔드에서는 간단하게 refere, Host 비교만으로 검증하는것으로 기본 방어가능
csrf 토큰사용하여 방어하기도함
</details> 

### 아키텍쳐

### 자료구조

### 인프라

<details> 
<summary> </summary>
</details> 

### 운영J


### 과제 

- 리뷰 시스템

- 티켓 예약 시스템

- 결제 시스템

- 검색 시스템